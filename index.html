<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Moon Posting Scheduler</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#4f46e5', /* Indigo */
                        'secondary': '#10b981', /* Emerald */
                        'background': '#f9fafb',
                        'accent': '#f59e0b', /* Amber */
                        'danger': '#ef4444', /* Red */
                    },
                      screens: {
                        'sm': '640px',
                        'md': '768px',
                        // CUSTOM BREAKPOINT: Only collapse to 1 column below 768px
                        'lg': '992px', 
                        'xl': '1280px',
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for better textarea visibility */
        textarea {
            font-size: 0.875rem; /* text-sm */
            line-height: 1.5;
            resize: vertical;
        }
        #rawDescription {
            min-height: 200px; /* Adjusted for compactness */
        }
        #calendarOutput {
            min-height: 250px;
        }
        #tagsOnlyOutput {
            min-height: 150px; /* Increased height for 3b */
        }
        #defaultTagsInput {
            font-size: 0.8rem; /* Smaller font for global hashtags */
        }
        /* FIX: Active tab highlight with RED text AND explicit BG color */
        .tab-button.active {
            border-bottom: 4px solid #ef4444 !important; /* Red */
            color: #ef4444 !important; /* Red */
            font-weight: 600 !important;
            background-color: #f1f5f9 !important; /* light gray for contrast */
        }
        /* Aggressively compacting the list items in settings */
        .compact-list-item {
            padding-top: 0.15rem; /* Further reduced padding */
            padding-bottom: 0.15rem;
            font-size: 0.75rem; /* text-xs for list content */
        }
        .compact-list-item span {
            font-size: 0.75rem;
        }
        /* Specific width for date picker */
        .date-input-container input[type="date"] {
            width: 150px; 
            max-width: 150px;
        }
        .sortable-drag {
            opacity: 0.6;
            background-color: #f1f5f9; /* Blue-gray for drag visual feedback */
        }
        /* FIX: Settings column structure - Using fixed grid definition for 30/70 split, only collapsing below 768px */
        .settings-grid-container-custom {
            display: grid;
            grid-template-columns: 30% 70%;
            gap: 2rem; 
        }
        @media (max-width: 768px) {
            .settings-grid-container-custom {
                grid-template-columns: 1fr;
            }
        }
        
        /* FIX: Explicit background colors for visual distinction (using !important to bypass overrides) */
        .schedule-container { background-color: #eef2ff !important; /* Indigo-50 */ }
        /* Adjusted background colors */
        .settings-column-one-bg { background-color: white !important; }
        .settings-column-two-bg { background-color: white !important; }
        /* Bulk Upload gets its amber/accent border only */
        .bulk-upload-bg { background-color: #fffbeb !important; } /* Amber-50 */
        .template-bg { background-color: #eef2ff !important; } /* Indigo-50 */
        .tag-add-bg { background-color: #f0fff4 !important; } /* Emerald-50 */


        /* Modal Styles */
        .modal {
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }
        .modal.active {
            pointer-events: auto;
            opacity: 1;
        }
        
        /* Collapsible Button Styling */
        .collapsible-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }

        /* Grouping style for reordering events */
        .event-group {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fff;
            border-radius: 8px;
        }
        
        /* === SCHEDULE COMPACTION STYLES === */
        /* Tighter padding on event cards */
        .scheduled-event-card {
            padding: 0.75rem !important; /* py-3 instead of py-4 */
            font-size: 0.8rem; /* text-sm reduced */
        }
        /* Smaller font for event header */
        .scheduled-event-card h3 {
            font-size: 1rem; /* text-base instead of lg */
        }
        .scheduled-event-card p {
            font-size: 0.75rem; /* text-xs */
        }
        /* Smaller textarea font and row padding */
        .scheduled-event-card textarea {
            font-size: 0.75rem; /* text-xs */
            padding: 0.3rem;
            line-height: 1.25;
        }
        /* Tighter button layout */
        .scheduled-event-card .flex-shrink-0 button {
            font-size: 0.7rem; /* text-xs */
            padding: 0.15rem 0.5rem;
        }
        .scheduled-event-card .text-sm {
            font-size: 0.75rem !important;
        }
        /* Tighter grid spacing */
        .scheduled-event-card .gap-2 {
            gap: 0.5rem;
        }
        /* Tighter padding for status buttons */
        .scheduled-event-card .flex-shrink-0 button {
            padding: 0.2rem 0.6rem;
            height: 24px;
        }
        /* Ensure event group header is still readable */
        .event-group h3 {
            font-size: 1.125rem; /* text-xl */
        }
    </style>
</head>
<body class="bg-background min-h-screen p-4 sm:p-8 font-sans">
    
    <!-- SUPABASE AND DRAG-N-DROP IMPORTS -->
    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
        window.supabaseClient = { createClient };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6 p-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-extrabold text-gray-900">Full Moon Week Posting</h1>
        </header>
        
        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 mb-6 bg-white rounded-t-xl shadow-md">
            <button id="tab-editor-btn" onclick="showTab('editor')" class="tab-button active flex-1 py-3 text-center transition duration-150">
                <svg class="w-5 h-5 inline mr-2 align-text-bottom" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 002 2h2a2 2 0 002-2"></path></svg>
                Event
            </button>
            <button id="tab-settings-btn" onclick="showTab('settings')" class="tab-button flex-1 py-3 text-center transition duration-150">
                <svg class="w-5 h-5 inline mr-2 align-text-bottom" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.525.323 1.144.38 1.724.161v-4.04z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                Settings
            </button>
            <button id="tab-scheduler-btn" onclick="showTab('scheduler')" class="tab-button flex-1 py-3 text-center transition duration-150">
                <svg class="w-5 h-5 inline mr-2 align-text-bottom" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                Schedule
            </button>
             <button id="tab-calendar-btn" onclick="showTab('calendar')" class="tab-button flex-1 py-3 text-center transition duration-150">
                <svg class="w-5 h-5 inline mr-2 align-text-bottom" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                Calendar
            </button>
            <button id="tab-history-btn" onclick="showTab('history')" class="tab-button flex-1 py-3 text-center transition duration-150">
                <svg class="w-5 h-5 inline mr-2 align-text-bottom" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                History
            </button>
        </div>

        <!-- MAIN EDITOR TAB -->
        <div id="tab-editor-content" class="tab-content">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                
                <!-- INPUT COLUMN (LEFT) -->
                <div class="space-y-6">
                    <!-- Structured Event Input -->
                    <div class="bg-white p-6 rounded-xl shadow-lg">
                        <label class="block text-xl font-semibold text-gray-900 mb-4 flex items-center">
                            Event Details
                        </label>

                        <!-- EVENT TEMPLATE LOADER -->
                        <div class="mb-4">
                            <label for="eventTemplateSelect" class="block text-sm font-medium text-gray-700 mb-1">Load Event Template:</label>
                            <select id="eventTemplateSelect" onchange="loadEventTemplate()" class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-primary focus:border-primary transition duration-150">
                                <option value="">--- Select Event Template ---</option>
                            </select>
                        </div>

                        <div class="space-y-3">
                            <!-- DATE INPUT (DATEPICKER ONLY) -->
                            <div class="flex items-center date-input-container space-x-3">
                                <label for="inputIsoDate" class="flex-shrink-0 text-sm font-medium text-gray-700">ðŸ—“ Event Date:</label>
                                <input type="date" id="inputIsoDate" class="border border-gray-300 rounded-lg p-2 text-sm focus:ring-primary focus:border-primary transition duration-150">
                            </div>
                            
                            <input type="text" id="inputEventName" placeholder="ðŸŽ‰ EVENT: " class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-primary focus:border-primary transition duration-150" onblur="loadEventExtraTags()">
                            <input type="text" id="inputLocation" placeholder="ðŸ“ LOCATION: " class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-primary focus:border-primary transition duration-150">
                        </div>
                        
                        <div class="flex justify-between items-center mt-6 mb-2">
                             <label for="rawDescription" class="block text-xl font-semibold text-gray-900 flex items-center">
                                Full Description
                            </label>
                            <!-- INSERT SNIPPET BUTTON/MENU -->
                            <div class="relative inline-block text-left">
                                <button type="button" onclick="document.getElementById('snippetMenu').classList.toggle('hidden')" class="px-3 py-1 bg-gray-100 text-gray-700 rounded-lg text-xs hover:bg-gray-200 transition">
                                    Insert Snippet
                                </button>
                                <div id="snippetMenu" class="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-10">
                                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                                        <select id="editorSnippetSelect" onchange="insertSnippet()" class="w-full p-2 text-sm cursor-pointer hover:bg-gray-100">
                                            <option value="">--- Select Snippet ---</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <textarea id="rawDescription" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-primary focus:border-primary transition duration-150" placeholder=""></textarea>

                        <label for="extraHashtagsInput" class="block text-sm font-medium text-gray-700 mt-4 mb-2">
                            Extra Hashtags (Comma-separated)
                        </label>
                        <input type="text" id="extraHashtagsInput" placeholder="Suggested tags for this event type will appear here." class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-primary focus:border-primary transition duration-150">
                    </div>
                    
                    <!-- File Mockup (Purpose Clarified) -->
                    <div class="bg-white p-6 rounded-xl shadow-lg">
                           <h2 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
                                Image/Video File Naming
                            </h2>
                        <!-- REMOVED FILE INPUT AND EXPLANATION -->
                        <button onclick="generateFileName()" class="mt-3 w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition text-sm">
                            Generate Suggested Filename
                        </button>
                        <p id="fileNameOutput" class="text-xs text-gray-700 mt-2 break-all"></p>
                    </div>
                </div>

                <!-- OUTPUT & ACTION COLUMN (RIGHT) -->
                <div class="space-y-6">
                    
                    <!-- FIX: Action (Moved to Top of Output Column & shrunk buttons) -->
                    <div class="bg-indigo-50/50 p-4 rounded-xl shadow-lg flex flex-col sm:flex-row items-center justify-between">
                        <div id="statusMessage" class="mt-4 sm:mt-0 text-sm text-gray-600 w-full mb-3 sm:mb-0 text-center sm:text-left">Connecting to Supabase...</div>
                        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 w-full justify-end">
                            <button id="parseButton" onclick="handleClick(false)" class="w-full sm:w-auto px-4 py-2 bg-primary text-white font-bold rounded-full shadow-md hover:bg-indigo-600 transition duration-300 transform hover:scale-105 text-sm">
                                PARSE
                            </button>
                            <button id="saveScheduleButton" onclick="handleClick(true)" class="w-full sm:w-auto px-4 py-2 bg-accent text-white font-bold rounded-full shadow-md hover:bg-amber-600 transition duration-300 transform hover:scale-105 text-sm">
                                SAVE TO SCHEDULE
                            </button>
                        </div>
                    </div>

                    <!-- OUTPUT BOXES (Stacked) -->
                    <div class="space-y-4">
                        <!-- Post Text -->
                        <div class="bg-white p-6 rounded-xl shadow-lg">
                            <label for="calendarOutput" class="block text-xl font-semibold text-gray-900 mb-2 flex items-center">
                                Post/Reel Text
                            </label>
                            <textarea id="calendarOutput" onblur="updateTextOutput('calendarOutput')" class="w-full border border-gray-300 rounded-lg p-3 bg-white min-h-[250px]" placeholder="Formatted post data will appear here."></textarea>
                        </div>
                        
                        <!-- Story Tags -->
                        <div class="bg-white p-6 rounded-xl shadow-lg">
                            <label for="tagsOnlyOutput" class="block text-xl font-semibold text-gray-900 mb-2 flex items-center">
                                Story Tags
                            </label>
                            <textarea id="tagsOnlyOutput" onblur="updateTextOutput('tagsOnlyOutput')" class="w-full border border-gray-300 rounded-lg p-3 bg-gray-50 min-h-[150px]" placeholder="Only unique @tags, one per line, will appear here."></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SETTINGS TAB (Layout Reverted to Screenshot Look) -->
        <div id="tab-settings-content" class="tab-content hidden">
            <!-- FIX: Grid with 30%/70% split, only collapsing to 1 column below 768px -->
            <div class="settings-grid-container-custom">
                
                <!-- Column 1: Tags, List, New Entry, Bulk Import (30% width) -->
                <div class="space-y-6">
                    <div class="settings-column-one-bg p-6 rounded-xl shadow-lg border border-gray-300">
                        <h2 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
                            <svg class="w-6 h-6 mr-2 text-secondary" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m-4 12v-2m4-10v2m-4 8v2m4-10v2m-4 8v2m4-10v2m-4 8v2m4-10v2m-4 8v2m4-10v2"></path></svg>
                            Tags
                        </h2>
                        
                        <!-- Filter & Search (Top of Tags Box) -->
                        <div class="space-y-3 mb-4">
                            <select id="categoryFilter" onchange="renderNameMap()" class="p-2 border border-gray-300 rounded-lg text-sm w-full">
                                <option value="">All Categories</option>
                                <option value="DJ">DJ</option>
                                <option value="Venue">Venue</option>
                                <option value="Presenter">Presenter</option>
                                <option value="Artist">Artist</option>
                                <option value="Label">Label</option>
                                <option value="Other">Other</option>
                            </select>
                            <input type="text" id="nameSearch" oninput="renderNameMap()" placeholder="Search by Name or Tag..." class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        </div>

                        <!-- Current List Display (The visible tags list) -->
                        <div class="max-h-96 overflow-y-scroll border border-gray-300 rounded-lg p-3 bg-gray-50">
                            <ul id="databaseList" class="divide-y divide-gray-200">
                                <!-- List items rendered here -->
                            </ul>
                            <p id="emptyListMessage" class="text-center text-gray-500 italic hidden mt-4">No entries found matching your filter/search criteria.</p>
                        </div>

                    </div>
                    
                    <!-- Add New Entry (Matches screenshot look) -->
                    <div class="tag-add-bg p-6 rounded-xl shadow-lg border border-secondary/50">
                             <h2 class="text-lg font-semibold text-gray-900 mb-3">Add New Tag:</h2>
                            <div class="space-y-3">
                                <input type="text" id="newName" placeholder="Name (e.g., John Smith)" class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-secondary focus:border-secondary">
                                <input type="text" id="newTag" placeholder="Tag (e.g., @JohnSmithOfficial)" class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-secondary focus:border-secondary">
                                <select id="newCategory" class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-secondary focus:border-secondary">
                                    <option value="DJ">DJ</option>
                                    <option value="Venue">Venue</option>
                                    <option value="Presenter">Presenter</option>
                                    <option value="Artist">Artist</option>
                                    <option value="Label">Label</option>
                                    <option value="Other">Other</option>
                                </select>
                                <button onclick="addNameMapEntry()" class="w-full py-2 bg-secondary text-white font-bold rounded-lg hover:bg-emerald-600 transition duration-200">
                                    Save
                                </button>
                                <p id="addStatus" class="text-xs mt-1"></p>
                            </div>
                    </div>
                        
                    <!-- Bulk Upload (Matches screenshot look) -->
                    <!-- FIX: Reverting background color to amber/yellow family for visual distinction and fixing tag -->
                    <div class="bulk-upload-bg p-6 rounded-xl shadow-lg border border-accent/50">
                             <h2 class="text-lg font-semibold text-gray-900 mb-3">Bulk Tag Database Import</h2>
                            <!-- FIX: Reverted description to include Tab-separated values -->
                            <p class="text-xs text-gray-700">Paste raw spreadsheet data (Name, @Tag, Category) below, or JSON, to merge with the cloud list.</p>
                            <button onclick="copyInitialInstaMap()" class="mt-3 px-3 py-1 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition text-xs">Copy Default Map JSON</button>
                            <textarea id="bulkInstaMapInput" placeholder='Name	@Tag	Category (Tab-separated)' class="w-full border border-gray-300 rounded-lg p-2 text-xs min-h-[100px]"></textarea>
                            <button onclick="bulkImportTags()" class="w-full py-2 bg-accent text-white font-bold rounded-lg hover:bg-amber-600 transition duration-200 text-sm">
                                IMPORT TAGS
                            </button>
                            <p id="bulkStatus" class="text-xs mt-1"></p>
                    </div>

                </div>

                <!-- Column 2: Global Settings, Snippets, Templates (70% width) -->
                <div class="space-y-6 flex flex-col">
                    
                    <!-- Reusable Text Snippets -->
                    <div class="settings-column-two-bg p-6 rounded-xl shadow-lg border border-gray-300">
                        <h2 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
                            <svg class="w-6 h-6 mr-2 text-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                            Reusable Text Snippets
                        </h2>
                         <div class="space-y-3">
                            <select id="snippetSelect" onchange="loadSnippet()" class="w-full border border-gray-300 rounded-lg p-2 text-sm">
                                <option value="">--- Load Snippet ---</option>
                            </select>
                            <textarea id="snippetContent" onblur="saveSnippet()" placeholder="" class="w-full border border-gray-300 rounded-lg p-3 text-sm min-h-[180px]"></textarea>
                            <div class="flex space-x-2">
                                <input type="text" id="snippetName" placeholder="Snippet Name" class="flex-1 p-2 border border-gray-300 rounded-lg text-sm">
                                <button onclick="saveSnippet()" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition text-sm">Save</button>
                            </div>
                            <p id="snippetStatus" class="text-xs mt-1"></p>
                        </div>
                    </div>

                    <!-- Global Default Hashtags (Moved to the bottom of the second column) -->
                    <div class="settings-column-two-bg p-6 rounded-xl shadow-lg border border-gray-300">
                        <h2 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
                            <svg class="w-6 h-6 mr-2 text-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                            Global Default Hashtags
                        </h2>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Tags added to all events. (Comma-separated)</label>
                        <textarea id="defaultTagsInput" onblur="saveGlobalHashtags()" class="w-full border border-gray-300 rounded-lg p-3 focus:ring-accent focus:border-accent transition duration-150" placeholder=""></textarea>
                         <p id="globalTagsStatus" class="text-xs mt-1"></p>
                    </div>

                </div>

            </div>
        </div>
        
        <!-- SCHEDULER TAB (NEW) -->
        <div id="tab-scheduler-content" class="tab-content hidden">
             <div class="schedule-container p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-gray-900 mb-4 flex items-center">
                    <svg class="w-7 h-7 mr-2 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Upcoming Post Schedule
                </h2 >
                <div id="scheduledEventsContainer" class="space-y-4">
                    <!-- Events grouped by date for Sortable lists -->
                </div>
                <p id="emptyScheduleMessage" class="text-center text-gray-500 italic mt-8 hidden">No events currently scheduled.</p>
            </div>
        </div>

        <!-- CALENDAR SUMMARY TAB (NEW) -->
        <div id="tab-calendar-content" class="tab-content hidden">
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-gray-900 mb-4 flex items-center">
                    <svg class="w-7 h-7 mr-2 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h.01M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    Full Moon Calendar View
                </h2 >
                <div id="calendarSummaryList" class="space-y-3">
                    <!-- Calendar summary content here -->
                </div>
                <p id="emptyCalendarMessage" class="text-center text-gray-500 italic mt-8 hidden">No events found for summary.</p>
            </div>
        </div>
        
        <!-- HISTORY TAB (NEW) -->
          <div id="tab-history-content" class="tab-content hidden">
             <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-gray-900 mb-4 flex items-center">
                    <svg class="w-7 h-7 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2l-1.5 1.5M12 6l1.5 1.5M4 18h16M4 6h16M12 10a2 2 0 00-2 2v3a2 2 0 002 2h3m0-6h-3a2 2 0 00-2 2v3m-6-6h.01M18 12h.01M6 18h.01"></path></svg>
                    Posting History (Past Events)
                </h2>
                <div id="historyEventsList" class="space-y-4">
                    <!-- Historical events populated here -->
                </div>
                <p id="emptyHistoryMessage" class="text-center text-gray-500 italic mt-8 hidden">No past events found.</p>
            </div>
        </div>

        <!-- CUSTOM DELETE MODAL -->
        <div id="deleteModal" class="modal fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-50" onclick="closeModal()">
            <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm mx-auto" onclick="event.stopPropagation()">
                <h3 class="text-lg font-bold text-red-600 mb-4">Confirm Deletion</h3>
                <p id="modalMessage" class="text-gray-700 mb-6">Are you sure you want to permanently delete this item?</p>
                <div class="flex justify-end space-x-3">
                    <button onclick="closeModal(false)" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button onclick="closeModal(true)" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">Delete</button>
                </div>
            </div>
        </div>
        
        <!-- CUSTOM PROMPT MODAL (New - for text input/renaming/template saving) -->
        <div id="promptModal" class="modal fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-50" onclick="closePromptModal(null)">
            <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm mx-auto w-full" onclick="event.stopPropagation()">
                <h3 id="promptModalTitle" class="text-lg font-bold text-primary mb-4">Enter Value</h3>
                <input type="text" id="promptModalInput" class="w-full p-2 border border-gray-300 rounded-lg mb-6" placeholder="Template Name">
                <div class="flex justify-end space-x-3">
                    <button onclick="closePromptModal(null)" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button onclick="submitPromptModal()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-indigo-600">Submit</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        
        // --- GLOBAL CONFIGURATION AND SUPABASE SETUP ---
        var DB_CONFIG = {
            INSTA_DB_KEY: 'name_tag_database', 
            EVENT_DB_KEY: 'event_templates',     
            SNIPPETS_KEY: 'text_snippets',       
            SCHEDULE_DB_KEY: 'event_schedule',   
            // REMOVED: MEDIA_LINK_KEY: 'media_link', 
            GLOBAL_TAGS_KEY: 'global_tags',      
            EXTRA_TAGS_KEY: 'event_extra_tags', 
            CATEGORIES: ["DJ", "Venue", "Presenter", "Artist", "Label", "Other"]
        };
        var CATEGORIES = DB_CONFIG.CATEGORIES; 
        
        // Global Supabase reference
        var supabase = null;
        
        // --- SUPABASE CREDENTIALS (NOW CORRECTLY SET) ---
        // NOTE: These keys are for public access and should be replaced with your own Supabase project keys.
        const SUPABASE_URL = 'https://wxaqneoanwgqgwraovkg.supabase.co'; 
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4YXFuZW9hbndncWd3cmFvdmtnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExMjY2NDYsImV4cCI6MjA3NjcwMjY0Nn0.yMpPWxyWlaDfnlGVpQ5gNkibp0k3KwW4KxjllKp5Iiw'; 
        
        // --- GLOBAL DATA STORES (Updated via Supabase Listeners) ---
        var nameTagDatabase = {}; 
        var eventDatabase = {};    
        var textSnippets = {};     
        var eventSchedule = [];    
        var globalTagsString = "fullmoonweek, fullmoonparty, kohphangan, thailand, parties, fullmoonpartykohphangan"; 
        var eventExtraTags = {}; 
        
        let resolveModalPromise = null;
        let resolvePromptPromise = null; 
        let currentEditingName = null;
        
        let saveScheduleTimeout = null; // Timeout reference for the 3.5 second delay

        // --- SUPABASE CLIENT INITIALIZATION ---
        
        async function initializeSupabase() {
            if (typeof window.supabaseClient === 'undefined' || !window.supabaseClient.createClient) {
                console.error("Supabase client library not loaded.");
                return;
            }
            
            try {
                supabase = window.supabaseClient.createClient(SUPABASE_URL, SUPABASE_KEY);
                
                await loadInitialDataAndListen(); 

                document.getElementById('statusMessage').textContent = `Ready to parse. Connected to Supabase.`;
                document.getElementById('statusMessage').className = 'mt-4 sm:mt-0 text-sm text-gray-600 w-full text-center sm:text-left';

            } catch (e) {
                console.error("Supabase Initialization Failed:", e);
                document.getElementById('statusMessage').textContent = `CRITICAL ERROR: ${e.message}. Data will not sync.`;
                document.getElementById('statusMessage').className = 'mt-4 sm:mt-0 text-sm text-red-600 font-bold w-full text-center sm:text-left';
            }
        }
        
        // --- SUPABASE DATA ACCESS LAYER ---
        const PRIMARY_RECORD_ID = 1;
        
        async function loadInitialDataAndListen() {
            if (!supabase) return; 

            const collections = [
                { name: DB_CONFIG.INSTA_DB_KEY, render: debouncedRenderNameMap, default: getInitialInstaMap(), globalVar: nameTagDatabase, type: 'map' },
                { name: DB_CONFIG.EVENT_DB_KEY, render: debouncedRenderEventTemplateSelect, default: {}, globalVar: eventDatabase, type: 'map' },
                { name: DB_CONFIG.SNIPPETS_KEY, render: debouncedRenderSnippetSelect, default: {}, globalVar: textSnippets, type: 'map' },
                { name: DB_CONFIG.SCHEDULE_DB_KEY, render: debouncedRenderScheduleList, default: [], globalVar: eventSchedule, type: 'array' },
                // REMOVED: { name: DB_CONFIG.MEDIA_LINK_KEY, render: debouncedRenderMediaLink, default: '', globalVar: mediaFolderLink, type: 'link' },
                { name: DB_CONFIG.GLOBAL_TAGS_KEY, render: debouncedRenderGlobalTags, default: globalTagsString, globalVar: window.globalTagsString, type: 'string' },
                { name: DB_CONFIG.EXTRA_TAGS_KEY, render: loadEventExtraTags, default: {}, globalVar: eventExtraTags, type: 'map' } 
            ];

            for (const { name, render, default: defaultData, globalVar, type } of collections) {
                
                // 1. Fetch initial data
                const { data, error: fetchError } = await supabase
                    .from(name)
                    .select('*')
                    .eq('id', PRIMARY_RECORD_ID)
                    .single();

                if (fetchError && fetchError.code !== 'PGRST116') { 
                     console.error(`Supabase Fetch Error for ${name}:`, fetchError);
                }
                
                let loadedData = null;

                if (data) {
                    if (type === 'array') loadedData = data.events;
                    // REMOVED: else if (type === 'link') loadedData = data.link;
                    else if (type === 'string') loadedData = data.tags;
                    else if (type === 'map') loadedData = data.data;
                }

                // 2. Update global variable
                if (loadedData !== null && loadedData !== undefined) {
                    if (type === 'array') {
                        globalVar.splice(0, globalVar.length, ...(loadedData || []));
                        globalVar.sort((a, b) => new Date(a.date) - new Date(b.date));
                    // REMOVED: } else if (type === 'link') {
                    // REMOVED:     window.mediaFolderLink = loadedData;
                    } else if (type === 'string') {
                        window.globalTagsString = loadedData;
                    } else if (type === 'map') {
                        for (const prop in globalVar) { delete globalVar[prop]; }
                        Object.assign(globalVar, loadedData);
                    }
                } else if (Object.keys(defaultData).length > 0 && type === 'map') {
                    if (Object.keys(globalVar).length === 0) {
                        Object.assign(globalVar, defaultData);
                        await saveDataToSupabase(name, defaultData);
                    }
                }
                
                // 3. Set up Realtime Subscription
                supabase.channel(`public_${name}`)
                    .on('postgres_changes', 
                        { event: 'UPDATE', schema: 'public', table: name, filter: `id=eq.${PRIMARY_RECORD_ID}` }, 
                        (payload) => {
                            const newData = payload.new;
                            if (newData) {
                                let updatedValue = null;
                                if (type === 'array') updatedValue = newData.events;
                                // REMOVED: else if (type === 'link') updatedValue = newData.link;
                                else if (type === 'string') updatedValue = newData.tags;
                                else if (type === 'map') updatedValue = newData.data;
                                
                                if (updatedValue !== null && updatedValue !== undefined) {
                                    if (type === 'array') {
                                        globalVar.splice(0, globalVar.length, ...(updatedValue || []));
                                        globalVar.sort((a, b) => new Date(a.date) - new Date(b.date));
                                    // REMOVED: } else if (type === 'link') {
                                    // REMOVED:     window.mediaFolderLink = updatedValue;
                                    } else if (type === 'string') {
                                        window.globalTagsString = updatedValue;
                                    } else if (type === 'map') {
                                        for (const prop in globalVar) { delete globalVar[prop]; }
                                        Object.assign(globalVar, updatedValue);
                                    }
                                    render();
                                }
                            }
                        }
                    )
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                             render(); 
                        }
                        if (status === 'CHANNEL_ERROR') {
                             console.error(`Supabase Subscription Error on ${name}: Connection failed or permission denied.`);
                        }
                    });

                render(); 
            }
        }
        
        async function saveDataToSupabase(tableName, data) {
            if (!supabase) { 
                console.error("Supabase client not initialized. Saving failed.");
                return false;
            }

            try {
                let payload = { id: PRIMARY_RECORD_ID };

                if (tableName === DB_CONFIG.SCHEDULE_DB_KEY) {
                    payload.events = data; 
                // REMOVED: } else if (tableName === DB_CONFIG.MEDIA_LINK_KEY) {
                // REMOVED:    payload.link = data;
                } else if (tableName === DB_CONFIG.GLOBAL_TAGS_KEY) {
                    payload.tags = data;
                } else {
                    payload.data = data; 
                }
                
                const { error } = await supabase
                    .from(tableName)
                    .upsert(payload, { onConflict: 'id' });
                
                if (error) {
                    console.error(`Error saving ${tableName} to Supabase:`, error);
                    return false;
                }
                return true;

            } catch (e) {
                console.error(`Unexpected error during Supabase save for ${tableName}:`, e);
                return false;
            }
        }
        
        // --- UTILITY FUNCTIONS ---
        
        function getTodayIsoString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Helper to get yesterday's date string for history auto-move logic
        function getYesterdayIsoString() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const year = yesterday.getFullYear();
            const month = String(yesterday.getMonth() + 1).padStart(2, '0');
            const day = String(yesterday.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).catch(err => {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed'; 
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                    } catch (e) {
                        console.error('Fallback copy method failed too:', e);
                    }
                    document.body.removeChild(textarea);
                });
            } else {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            }
        }
        
        function formatDateFriendly(isoDate) {
            if (!isoDate) return 'TBD Date';
            try {
                const date = new Date(isoDate + 'T00:00:00'); // Append time to prevent timezone issues
                return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
            } catch (e) {
                return isoDate;
            }
        }
        
        function dateDifference(date1, date2) {
            const date1Time = date1.getTime();
            const date2Time = date2.getTime();
            const diffTime = Math.abs(date2Time - date1Time);
            return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        }

        function generateFileName() {
            const date = document.getElementById('inputIsoDate').value.trim();
            const location = document.getElementById('inputLocation').value.trim();

            if (!date || !location) {
                document.getElementById('fileNameOutput').textContent = "Enter Date and Location to generate filename.";
                return 'N/A';
            }

            const d = new Date(date + 'T00:00:00');
            const month = d.toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
            const day = String(d.getDate()).padStart(2, '0');
            
            const cleanLocation = location
                .replace(/[^a-zA-Z0-9\s]/g, '')
                .trim()
                .replace(/\s+/g, '_')
                .toUpperCase();

            const filename = `${day}${month}-${cleanLocation}`;
            
            document.getElementById('fileNameOutput').textContent = `${filename}.jpg/mp4 (Copy Manually)`;
            return filename;
        }

        function updateTextOutput(id) { /* Placeholder */ }
        
        // --- MODAL CONFIRMATION (for reliable deletion) ---

        function openModal(message) {
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('deleteModal').classList.add('active');
            return new Promise(resolve => {
                resolveModalPromise = resolve;
            });
        }

        function closeModal(confirmed) {
            document.getElementById('deleteModal').classList.remove('active');
            if (resolveModalPromise) {
                resolveModalPromise(confirmed);
                resolveModalPromise = null;
            }
        }
        
        // --- PROMPT MODAL (New - for text input/renaming/template saving) ---
        
        function openPromptModal(title, defaultValue = '') {
            document.getElementById('promptModalTitle').textContent = title;
            const inputEl = document.getElementById('promptModalInput');
            inputEl.value = defaultValue;
            inputEl.placeholder = title; 
            document.getElementById('promptModal').classList.add('active');
            
            setTimeout(() => inputEl.focus(), 100);

            return new Promise(resolve => {
                resolvePromptPromise = resolve;
            });
        }

        function closePromptModal(value) {
            document.getElementById('promptModal').classList.remove('active');
            if (resolvePromptPromise) {
                resolvePromptPromise(value);
                resolvePromptPromise = null;
            }
        }

        function submitPromptModal() {
            const value = document.getElementById('promptModalInput').value.trim();
            closePromptModal(value);
        }
        
        // --- DATA STRUCTURES ---

        function getInitialInstaMap() {
             return {"2nd Floor Sunset Bar":{"tag":"@2ndfloor.sunsetbar","category":"Venue"},"3MAN":{"tag":"@3man_uk","category":"DJ"},"Aaron Suiss":{"tag":"@aaronsuissofficial","category":"DJ"},"Aatma":{"tag":"@aatmawithin","category":"DJ"},"Abro":{"tag":"@abro.ofc","category":"DJ"},"Acker":{"tag":"@acker_phangan","category":"DJ"},"Acrobat":{"tag":"@acrobat.music","category":"DJ"},"Adi Oren":{"tag":"@_adioren_","category":"DJ"},"Adi Shabat":{"tag":"@adishabat_","category":"DJ"},"AFTERLIFE label":{"tag":"@afterlife_ofc","category":"Label"},"Akshit Shetty":{"tag":"@akshit_shetty","category":"DJ"},"Alan Koh":{"tag":"@alan.island_","category":"DJ"},"Alviker":{"tag":"@alviker","category":"DJ"},"Amiram":{"tag":"@ami_rising_dust","category":"DJ"},"Angelika":{"tag":"@djangelikaofficial","category":"DJ"},"Anna Panilli":{"tag":"@annapanilli","category":"DJ"},"Annabelle":{"tag":"@djparty_kohphangan","category":"DJ"},"Anuyut":{"tag":"@living_things_studio","category":"DJ"},"Apnea":{"tag":"@apneanarchy","category":"DJ"},"Apple Bar, Haad Yao":{"tag":"@applebarhaadyao","category":"Venue"},"Aracil":{"tag":"@aracil_official","category":"DJ"},"Armi":{"tag":"@djarmikp","category":"DJ"},"ArtCore":{"tag":"@ron_levanon_artcore","category":"Artist"},"Artur Snake":{"tag":"@artursnakefilm","category":"DJ"},"Assaf Almog":{"tag":"@dj_assaf_almog","category":"DJ"},"Astrida":{"tag":"@astrida_astridakini","category":"DJ"},"Atman Ananda":{"tag":"@atmanananda_dj","category":"DJ"},"AUM Sound Healing Center":{"tag":"@aumsoundhealing","category":"Venue"},"B.E.M.E.T":{"tag":"@b_e_m_e_t","category":"DJ"},"B14CKPE4R1S":{"tag":"@_b14ckpe4r1s_","category":"DJ"},"B4gle":{"tag":"@b4gle","category":"DJ"},"Back to Donnie":{"tag":"@donniemusic","category":"DJ"},"Bambu":{"tag":"@bambuhuts","category":"Venue"},"Bank Waterfall":{"tag":"@Bank_Waterfall","category":"DJ"},"Barak White":{"tag":"@barakwhite","category":"DJ"},"Bata":{"tag":"@batasamuilover","category":"Artist"},"Bello":{"tag":"@BelloDJ","category":"Category"},"Berry Linn":{"tag":"@Berry_Linn","category":"DJ"},"Big Splash":{"tag":"@Big_Splash_DnBPresenter","category":"Presenter"},"Black Barrel":{"tag":"@blackbarrel_leocap","category":"DJ"},"Black Venus":{"tag":"@blackvenus__","category":"DJ"},"Bluerama":{"tag":"@bluerama_official","category":"Venue"},"Boyonic":{"tag":"@boyonic7","category":"DJ"},"Brahma":{"tag":"@brahma_music","category":"DJ"},"Bushwacka!":{"tag":"@bushwacka","category":"DJ"},"Cafe 13 Koh Phangan":{"tag":"@cafe13_kohphangan","category":"Venue"},"Cartel De Los Amigos":{"tag":"@carteldelosamigos","category":"Presenter"},"Chill Up":{"tag":"@chill_up_phangan","category":"Venue"},"Chupis":{"tag":"@mr_chupis","category":"DJ"},"Cleo P":{"tag":"@djcleop","category":"DJ"},"Cocoyard":{"tag":"@cocoyard.th","category":"Venue"},"Cosimo Scimo":{"tag":"@cosimoscimo33_45","category":"DJ"},"Cosmic Vibes":{"tag":"@djcosmicvibes","category":"DJ"},"Cosmosis":{"tag":"@cosmosis1","category":"DJ"},"Crealab108":{"tag":"@crealab108_uv_artwork","category":"Artist"},"Culture Club":{"tag":"@cultureclub.kpg","category":"Venue"},"D-Unity":{"tag":"@d_unity","category":"DJ"},"Dalah":{"tag":"@dalahfr","category":"DJ"},"Dani V":{"tag":"@ddjdaniv","category":"DJ"},"Darco":{"tag":"@____darco____","category":"DJ"},"Darin Epsilon":{"tag":"@darinepsilon","category":"DJ"},"Darragh Casey":{"tag":"@darraghcasey","category":"DJ"},"Darwish":{"tag":"@djdarwish","category":"DJ"},"Dava Di Toma":{"tag":"@davaditoma","category":"DJ"},"David Chong":{"tag":"@dj_david_chong","category":"DJ"},"Deborah De Luca":{"tag":"@deborahdeluca","category":"DJ"},"Denium":{"tag":"@hill","category":"DJ"},"Denoit has been changed to Denium, this is to ensure that the code is correct, and will not cause an error.":{"tag":"@denishorvat","category":"DJ"},"Dennis Lee":{"tag":"@djdennislee","category":"DJ"},"Dennyck":{"tag":"@davidenicolucci","category":"DJ"},"Densoner":{"tag":"@dens_oner","category":"DJ"},"Desert Sail":{"tag":"@desert_sail_music","category":"DJ"},"Dima Odivo":{"tag":"@dima_odivo","category":"DJ"},"Disco Boi":{"tag":"@yigital_","category":"DJ"},"DJ Bishh":{"tag":"@dj.bishh","category":"DJ"},"DJ Danny Dan":{"tag":"@danny_trunprodigital","category":"DJ"},"DJ Darkus":{"tag":"@djdarkus12","category":"DJ"},"DJ Flim":{"tag":"@djflimofficial","category":"DJ"},"DJ Noize":{"tag":"@noizefmp","category":"DJ"},"DJ NOT":{"tag":"@djjj_not","category":"DJ"},"DJ NowAnanda":{"tag":"@nowananda.music","category":"DJ"},"DJ Profile":{"tag":"@djprofileuk","category":"DJ"},"DJ Sith":{"tag":"@djsith555","category":"DJ"},"DJ Yam":{"tag":"@djy.a.m.","category":"DJ"},"DJ Yamagushi":{"tag":"@dj.yamagushi","category":"DJ"},"DJâ€‹xMC Paekingboom":{"tag":"@pae_kingboom","category":"DJ"},"Doc":{"tag":"@doc.moh77","category":"DJ"},"Dovetail":{"tag":"@dovetail.sounds","category":"DJ"},"Dr. Knows":{"tag":"@mr.andidressler","category":"DJ"},"Dragos":{"tag":"@dragos_kpg","category":"DJ"},"Dust":{"tag":"@dustlooneymoon","category":"DJ"},"Dusty Kid":{"tag":"@dustykid_official","category":"DJ"},"Dyslex":{"tag":"@dyslex_phangan","category":"DJ"},"E-Mook":{"tag":"@dj_e.mook","category":"DJ"},"Echo Beach":{"tag":"@echo_beach_hostel","category":"Venue"},"Eden Party":{"tag":"@edengarden_kohphangan","category":"Venue"},"El Gluck":{"tag":"@el.gluck","category":"DJ"},"Electrom":{"tag":"@electromdj","category":"DJ"},"Eli Cicada":{"tag":"@eli.cicada","category":"DJ"},"Erkin Ekici":{"tag":"@erkinekicii","category":"DJ"},"Esterlis":{"tag":"@alex_esterlis","category":"DJ"},"eva180":{"tag":"@eva_brabus_180","category":"DJ"},"Evgeny Sviridov":{"tag":"@evgeny.sviridov_ofc","category":"DJ"},"ð”½ð”¸ð”½ð”¸ (People on Top)":{"tag":"@fafa.peopleontop","category":"DJ"},"Farid":{"tag":"@farid__ofc","category":"DJ"},"Felon MC":{"tag":"@felonmc","category":"DJ"},"Fred Canal":{"tag":"@fredcanal","category":"DJ"},"Freestylers":{"tag":"@thefreestylersofficial","category":"DJ"},"Funkintao":{"tag":"@vroom.music","category":"DJ"},"Fuziger":{"tag":"@FuzigerDJ","category":"DJ"},"Gadi Schneider":{"tag":"@gadi__schneider","category":"DJ"},"Gana Eden":{"tag":"@gana_eden","category":"DJ"},"Gayatree":{"tag":"@dj_osman_gayatree","category":"DJ"},"Genetica":{"tag":"@genetica_music","category":"DJ"},"Gera Dzhio":{"tag":"@gera_dzhio","category":"DJ"},"Ghost Rider":{"tag":"@ghostrider.music","category":"DJ"},"Gily":{"tag":"@iamgily","category":"DJ"},"Global Flaming":{"tag":"@global_flaming","category":"Artist"},"Golo":{"tag":"@omergolo","category":"DJ"},"Goodman":{"tag":"@GoodmanDJ","category":"DJ"},"Gorovich":{"tag":"@gorovich_official","category":"DJ"},"Graham Gold":{"tag":"@djgrahamgold","category":"DJ"},"Grasshopper Bar":{"tag":"@grasshopperbeachbar","category":"Venue"},"Greg Hilight Tribe":{"tag":"@greghilight","category":"DJ"},"Groovy Tunes":{"tag":"@groovy"}};
        }

        // --- UI CONTROL ---
        
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));

            document.getElementById(`tab-${tabName}-content`).classList.remove('hidden');
            document.getElementById(`tab-${tabName}-btn`).classList.add('active');
            
            // Expensive calculations or renders only run when the tab is explicitly opened
            if (tabName === 'scheduler') {
                renderScheduleList();
                initializeSortable(); 
            } else if (tabName === 'calendar') {
                 renderCalendarSummary();
            } else if (tabName === 'settings') {
                document.getElementById('defaultTagsInput').value = globalTagsString;
                renderEditorSnippetSelect();
            } else if (tabName === 'editor') {
                 renderEditorSnippetSelect();
            } else if (tabName === 'history') {
                 renderScheduleList(); 
            }
        }
        
        function toggleCollapsible(id, button) {
            const content = document.getElementById(id);
            const state = button.getAttribute('data-state');
            const svg = button.querySelector('svg');
            
            if (state === 'collapsed') {
                content.classList.remove('hidden');
                button.setAttribute('data-state', 'expanded');
                if(svg) svg.classList.add('rotate-180');
            } else {
                content.classList.add('hidden');
                button.setAttribute('data-state', 'collapsed');
                if(svg) svg.classList.remove('rotate-180');
            }
        }

        // --- FULL MOON CALENDAR DATES (for grouping) ---
        const FULL_MOON_BLOCKS = [
            // 2025
            { peak: '2025-02-13', name: 'Feb 2025' },
            { peak: '2025-03-13', name: 'Mar 2025' },
            { peak: '2025-04-12', name: 'Apr 2025' },
            { peak: '2025-05-12', name: 'May 2025' },
            { peak: '2025-06-10', name: 'Jun 2025' },
            { peak: '2025-07-12', name: 'Jul 2025' },
            { peak: '2025-08-09', name: 'Aug 2025' },
            { peak: '2025-09-07', name: 'Sep 2025' },
            { peak: '2025-10-08', name: 'Oct 2025' },
            { peak: '2025-11-05', name: 'Nov 2025' },
            { peak: '2025-12-05', name: 'Dec 2025' },
            // Overlapping New Year Block 
            { peak: '2025-12-31', name: 'New Year (Dec 2025/Jan 2026)', endPeak: '2026-01-03' }, 
            // 2026 (Starts from 2 Feb, avoiding the combined block above)
            { peak: '2026-02-02', name: 'Feb 2026' },
            { peak: '2026-03-03', name: 'Mar 2026' },
            { peak: '2026-04-02', name: 'Apr 2026' },
            { peak: '2026-05-01', name: 'May 2026' },
            { peak: '2026-05-31', name: 'May/Jun 2026' },
            { peak: '2026-06-29', name: 'Jun 2026' },
            { peak: '2026-07-29', name: 'Jul 2026' },
            { peak: '2026-08-28', name: 'Aug 2026' },
            { peak: '2026-09-26', name: 'Sep 2026' },
            { peak: '2026-10-26', name: 'Oct 2026' },
            { peak: '2026-11-24', name: 'Nov 2026' },
            { peak: '2026-12-24', name: 'Dec 2026' },
        ];


        function assignFullMoonBlock(event) {
            const eventDate = new Date(event.date + 'T00:00:00');
            
            for (const block of FULL_MOON_BLOCKS) {
                const peakDate = new Date(block.peak + 'T00:00:00');
                
                const endPeakDate = block.endPeak ? new Date(block.endPeak + 'T00:00:00') : peakDate;
                
                const startDate = new Date(peakDate.getTime() - (7 * 24 * 60 * 60 * 1000));
                const endDate = new Date(endPeakDate.getTime() + (7 * 24 * 60 * 60 * 1000));

                if (eventDate >= startDate && eventDate <= endDate) {
                    
                    let displayTitle = block.name;
                    
                    return { 
                        ...event, 
                        blockKey: block.peak, 
                        blockName: displayTitle,
                        blockStart: startDate.toISOString().split('T')[0],
                        blockEnd: endDate.toISOString().split('T')[0]
                    };
                }
            }
            return { ...event, blockKey: 'Ungrouped', blockName: 'Ungrouped/Other' };
        }


        function calculateSequentialDays(events) {
            const DAY_RESET_THRESHOLD = 7; 
            
            if (events.length === 0) return [];
            
            const sortedEvents = [...events].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let lastDate = null;
            
            const eventsWithDay = [];
            
            for (const event of sortedEvents) {
                const currentDate = new Date(event.date + 'T00:00:00');
                let newDayNumber = event.dayNumber; 
                
                if (!lastDate) {
                    newDayNumber = 1;
                } else {
                    const diffDays = dateDifference(lastDate, currentDate);
                    
                    if (diffDays > DAY_RESET_THRESHOLD) {
                        newDayNumber = 1;
                    } else if (diffDays > 0) {
                        const lastEvent = eventsWithDay[eventsWithDay.length - 1];
                        newDayNumber = lastEvent.dayNumber + diffDays;
                    } else {
                        const lastEvent = eventsWithDay[eventsWithDay.length - 1];
                        newDayNumber = lastEvent.dayNumber;
                    }
                }
                
                const newEvent = { ...event, dayNumber: newDayNumber };
                eventsWithDay.push(newEvent);
                lastDate = currentDate; 
            }

            return eventsWithDay;
        }


        function renderCalendarSummary() {
            const listEl = document.getElementById('calendarSummaryList');
            const messageEl = document.getElementById('emptyCalendarMessage');
            if (!listEl || !messageEl) return;

            listEl.innerHTML = '';
            
            const allEventsWithDay = calculateSequentialDays(eventSchedule);
            const allEventsWithBlock = allEventsWithDay.map(assignFullMoonBlock);


            if (allEventsWithBlock.length === 0) {
                messageEl.classList.remove('hidden');
                return;
            }
            
            const todayISO = getTodayIsoString();
            
            const groupedByYear = allEventsWithBlock.reduce((acc, event) => {
                const year = new Date(event.date + 'T00:00:00').getFullYear();
                if (!acc[year]) acc[year] = {};

                const blockKey = event.blockKey;
                
                if (!acc[year][blockKey]) acc[year][blockKey] = { 
                    title: event.blockName, 
                    events: [],
                };
                
                acc[year][blockKey].events.push(event);
                return acc;
            }, {});

            
            const renderGroup = (title, events, isCollapsed = false, containerId) => {
                if (events.length === 0) return '';
                
                const groupId = `calendar-group-${containerId}`;
                let html = '';
                
                const isPast = events.every(e => e.date < todayISO);

                html += `
                    <button onclick="toggleCollapsible('${groupId}', this)" class="collapsible-btn bg-gray-100 hover:bg-gray-200 mt-4" data-state="${isCollapsed ? 'collapsed' : 'expanded'}">
                        ${title} (${events.length} events) ${isPast ? '<span class="text-xs text-gray-500 ml-2">(Past)</span>' : ''}
                        <svg class="w-4 h-4 transform transition-transform ${isCollapsed ? '' : 'rotate-180'}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="${groupId}" class="${isCollapsed ? 'hidden' : ''} space-y-3 p-2 border border-gray-200 rounded-lg">
                `;
                
                const groupedByDate = events.reduce((acc, event) => {
                    const dateKey = event.date;
                    if (!acc[dateKey]) acc[dateKey] = [];
                    acc[dateKey].push(event);
                    return acc;
                }, {});

                for (const dateKey of Object.keys(groupedByDate).sort()) {
                    const dateGroup = groupedByDate[dateKey];
                    const friendlyDate = dateGroup[0].inputDateFriendly.toUpperCase().replace(/\, \d{4}/, ''); 
                    
                    html += `<h4 class="text-sm font-semibold text-gray-900 mt-2">${friendlyDate}:</h4>`;
                    
                    dateGroup.forEach(event => {
                        html += `<p class="text-xs text-gray-700 ml-2">Day ${event.dayNumber}: ${event.location} - ${event.eventName}</p>`;
                    });
                }
                
                html += '</div>';
                return html;
            };

            const yearKeys = Object.keys(groupedByYear).sort();
            
            yearKeys.forEach((yearKey, yearIndex) => {
                const yearEvents = groupedByYear[yearKey];
                
                const yearId = `year-${yearKey}`;
                const isCurrentYear = new Date().getFullYear().toString();
                const isYearCollapsed = yearKey !== isCurrentYear; 

                
                const yearButton = document.createElement('button');
                yearButton.className = 'collapsible-btn bg-primary text-white hover:bg-indigo-600 w-full mt-6';
                yearButton.setAttribute('data-state', isYearCollapsed ? 'collapsed' : 'expanded');
                yearButton.setAttribute('onclick', `toggleCollapsible('${yearId}', this)`);
                yearButton.innerHTML = `YEAR ${yearKey} <svg class="w-4 h-4 transform transition-transform ${isYearCollapsed ? '' : 'rotate-180'}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>`;
                listEl.appendChild(yearButton);

                const yearContent = document.createElement('div');
                yearContent.id = yearId;
                yearContent.className = isYearCollapsed ? 'hidden space-y-4 p-4 border border-primary/50 rounded-b-lg' : 'space-y-4 p-4 border border-primary/50 rounded-b-lg';
                
                const sortedBlockKeys = Object.keys(yearEvents).sort();

                sortedBlockKeys.forEach(blockKey => {
                    const block = yearEvents[blockKey];
                    
                    yearContent.innerHTML += renderGroup(
                        block.title, 
                        block.events, 
                        isYearCollapsed, 
                        `${yearKey}-${blockKey.replace(/[^a-zA-Z0-9]/g, '')}`
                    );
                });

                listEl.appendChild(yearContent);
            });
            
            messageEl.classList.toggle('hidden', allEventsWithBlock.length > 0);
        }

        // --- DATA MANAGEMENT: NAME-TAG DB ---

        // Debounce function to limit how often renders happen due to rapid updates
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        };

        const debouncedRenderNameMap = debounce(renderNameMap, 100);
        const debouncedRenderSnippetSelect = debounce(renderSnippetSelect, 100);
        const debouncedRenderEventTemplateSelect = debounce(renderEventTemplateSelect, 100);
        const debouncedRenderGlobalTags = debounce(renderGlobalTags, 100);
        const debouncedRenderScheduleList = debounce(renderScheduleList, 100);
        const debouncedRenderCalendarSummary = debounce(renderCalendarSummary, 100);


        function setStatus(elementId, message, isError = false) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.textContent = message;
            el.className = `text-xs mt-1 ${isError ? 'text-red-600' : 'text-secondary'}`;
        }

        function copyInitialInstaMap() {
            const mapJson = JSON.stringify(getInitialInstaMap(), null, 2);
            copyToClipboard(mapJson);
            setStatus('bulkStatus', 'Default map copied to clipboard. Paste into the box above.');
        }

        async function bulkImportTags() {
            const inputStr = document.getElementById('bulkInstaMapInput').value.trim();
            
            if (!inputStr) {
                setStatus('bulkStatus', 'Error: Paste data before importing.', true);
                return;
            }

            try {
                let importedData = {};
                
                try {
                    importedData = JSON.parse(inputStr);
                    if (typeof importedData !== 'object' || Array.isArray(importedData)) {
                         throw new Error("JSON format invalid. Expecting an object map.");
                    }
                } catch(e) {
                    console.log("JSON parsing failed, attempting spreadsheet parse...");
                    const lines = inputStr.split('\n').filter(line => line.trim().length > 0);
                    
                    if(lines.length === 0) throw new Error("Could not parse data as JSON or Spreadsheet.");

                    lines.forEach(line => {
                        const separator = line.includes('\t') ? '\t' : (line.includes(',') ? ',' : null);
                        
                        const parts = line.split(separator || ' ').map(p => p.trim()).filter(p => p.length > 0);
                        if (parts.length < 2) return; 

                        const name = parts[0];
                        let tag = parts[1];
                        const category = parts[2] || 'Other';
                        
                        if (!name || !tag) return;

                        if (!tag.startsWith('@') && !tag.startsWith('#')) {
                            tag = '@' + tag;
                        }
                        importedData[name] = { tag: tag, category: category };
                    });

                    if (Object.keys(importedData).length === 0) throw new Error("No valid data found in input.");
                }
                
                const mergedData = { ...nameTagDatabase, ...importedData };
                
                for (const key in mergedData) {
                    const item = mergedData[key];
                    if (!item || typeof item.tag !== 'string' || typeof item.category !== 'string') {
                         throw new Error(`Invalid structure for key "${key}". Must contain "tag" and "category".`);
                    }
                }
                
                for (const prop in nameTagDatabase) { delete nameTagDatabase[prop]; }
                Object.assign(nameTagDatabase, mergedData);
                
                const saveSuccess = await saveDataToSupabase(DB_CONFIG.INSTA_DB_KEY, nameTagDatabase);
                
                if (saveSuccess) {
                    document.getElementById('bulkInstaMapInput').value = '';
                    setStatus('bulkStatus', `Success! Merged ${Object.keys(importedData).length} entries and saved to cloud.`);
                } else {
                    setStatus('bulkStatus', 'Import Error: Failed to save to Supabase.', true);
                }
                
            } catch (e) {
                setStatus('bulkStatus', `Import Error: ${e.message}`, true);
            }
        }
        
        async function addNameMapEntry() {
            const name = document.getElementById('newName').value.trim();
            let tag = document.getElementById('newTag').value.trim();
            const category = document.getElementById('newCategory').value;
            const statusEl = document.getElementById('addStatus');

            if (!name || !tag || !category) {
                setStatus('addStatus', 'Error: All fields are required.', true);
                return;
            }
            if (!tag.startsWith('@') && !tag.startsWith('#')) {
                tag = '@' + tag;
            }
            if (nameTagDatabase[name]) {
                setStatus('addStatus', `Error: Name "${name}" already exists. Edit it instead.`, true);
                return;
            }

            nameTagDatabase[name] = { tag, category };
            const saveSuccess = await saveDataToSupabase(DB_CONFIG.INSTA_DB_KEY, nameTagDatabase);
            
            if (saveSuccess) {
                document.getElementById('newName').value = '';
                document.getElementById('newTag').value = '';
                setStatus('addStatus', `Entry "${name}" saved successfully.`);
            } else {
                 setStatus('addStatus', 'Error: Failed to save to Supabase.', true);
            }
        }


        function renderNameMap() {
            const listEl = document.getElementById('databaseList');
            const searchVal = document.getElementById('nameSearch').value.toLowerCase();
            const filterCat = document.getElementById('categoryFilter').value;
            
            if (!listEl) return; 
            
            listEl.innerHTML = '';
            
            const entries = Object.entries(nameTagDatabase).map(([name, data]) => ({
                name: name,
                tag: data.tag,
                category: data.category || 'Other'
            }));
            
            const filteredEntries = entries.filter(entry => {
                const nameMatch = entry.name.toLowerCase().includes(searchVal) || entry.tag.toLowerCase().includes(searchVal);
                const categoryMatch = !filterCat || entry.category === filterCat;
                return nameMatch && categoryMatch;
            });

            filteredEntries.sort((a, b) => a.name.localeCompare(b.name));

            filteredEntries.forEach(({ name, tag, category }) => {
                const isEditing = name === currentEditingName;

                const li = document.createElement('li');
                li.className = 'compact-list-item flex justify-between items-center text-xs'; 
                
                if (isEditing) {
                    li.innerHTML = `
                        <div class="flex-1 min-w-0 pr-1 space-y-1">
                            <input type="text" id="editName-${name}" value="${name}" placeholder="Name" 
                                class="font-medium text-gray-900 w-full bg-white border border-secondary rounded p-1 text-xs focus:ring-secondary focus:border-secondary"> 
                            <div class="flex items-center space-x-1">
                                <input type="text" id="editTag-${name}" value="${tag}" placeholder="Tag"
                                    class="flex-1 bg-white border border-secondary rounded p-1 text-xs text-secondary focus:ring-secondary focus:border-secondary">
                                <select id="editCategory-${name}"
                                        class="bg-white border border-secondary rounded p-1 text-xs text-gray-500 focus:ring-secondary focus:border-secondary flex-shrink-0 w-16">
                                    ${CATEGORIES.map(c => `<option value="${c}" ${c === category ? 'selected' : ''}>${c}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <div class="flex items-center space-x-1 flex-shrink-0">
                            <button onclick="saveNameMapEdit('${name}')" class="text-secondary hover:text-emerald-700 p-1 rounded hover:bg-emerald-50 transition" title="Save Edit">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                            </button>
                            <button onclick="cancelNameMapEdit()" class="text-gray-500 hover:text-gray-700 p-1 rounded hover:bg-gray-50 transition" title="Cancel Edit">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                        </div>
                    `;
                } else {
                    li.innerHTML = `
                        <div class="flex-1 min-w-0 pr-1 truncate space-y-0">
                            <span class="font-medium text-gray-900">${name}</span>
                            <div class="flex items-center space-x-2">
                                <span class="text-secondary">${tag}</span>
                                <span class="text-gray-500 text-xs">(${category})</span>
                            </div>
                        </div>
                        <div class="flex items-center space-x-1 flex-shrink-0">
                            <button onclick="startNameMapEdit('${name}')" class="text-primary hover:text-indigo-600 p-1 rounded hover:bg-indigo-50 transition" title="Edit Entry">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                            </button>
                            <button onclick="copyToClipboard('${tag}')" class="text-primary hover:text-indigo-600 p-1 rounded hover:bg-indigo-50 transition" title="Copy Tag">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2"></path></svg>
                            </button>
                            <button data-name="${name}" onclick="handleDeleteNameMapEntry(this)" class="text-red-500 hover:text-red-700 p-1 rounded hover:bg-red-50 transition" title="Remove Entry">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </div>
                    `;
                }
                listEl.appendChild(li);
            });
            
            document.getElementById('emptyListMessage').classList.toggle('hidden', filteredEntries.length > 0);
        }
        
        function startNameMapEdit(name) {
            currentEditingName = name;
            debouncedRenderNameMap(); // Use debounced render to update the view
        }

        function cancelNameMapEdit() {
            currentEditingName = null;
            debouncedRenderNameMap();
        }

        async function saveNameMapEdit(oldName) {
            const newName = document.getElementById(`editName-${oldName}`).value.trim();
            let newTag = document.getElementById(`editTag-${oldName}`).value.trim();
            const newCategory = document.getElementById(`editCategory-${oldName}`).value;
            const statusEl = document.getElementById('addStatus'); 

            if (!newName || !newTag || !newCategory) {
                setStatus('addStatus', "Error: All fields are required.", true);
                return;
            }
            if (!newTag.startsWith('@') && !newTag.startsWith('#')) {
                newTag = '@' + newTag;
            }

            if (newName !== oldName && nameTagDatabase[newName]) {
                setStatus('addStatus', 'Error: New name already exists!', true);
                return;
            }

            if (oldName !== newName) {
                delete nameTagDatabase[oldName];
                nameTagDatabase[newName] = { tag: newTag, category: newCategory };
            } else {
                 nameTagDatabase[oldName].tag = newTag;
                 nameTagDatabase[oldName].category = newCategory;
            }
            
            currentEditingName = null;
            const saveSuccess = await saveDataToSupabase(DB_CONFIG.INSTA_DB_KEY, nameTagDatabase);
            if (saveSuccess) {
                 setStatus('addStatus', `Entry "${newName}" updated successfully.`);
            } else {
                 setStatus('addStatus', 'Error: Failed to save to Supabase.', true);
            }
        }

        async function handleDeleteNameMapEntry(button) {
            const nameToRemove = button.getAttribute('data-name');
            const confirmed = await openModal(`Are you sure you want to permanently delete the tag entry for "${nameToRemove}"?`);

            if (confirmed) {
                delete nameTagDatabase[nameToRemove];
                await saveDataToSupabase(DB_CONFIG.INSTA_DB_KEY, nameTagDatabase);
            }
        }
        
        async function saveGlobalHashtags() {
            const tags = document.getElementById('defaultTagsInput').value.trim();
            if (tags === globalTagsString) return;

            window.globalTagsString = tags;
            const saveSuccess = await saveDataToSupabase(DB_CONFIG.GLOBAL_TAGS_KEY, tags);
            
            if (saveSuccess) {
                setStatus('globalTagsStatus', 'Global tags saved!');
                document.getElementById('defaultTagsInput').value = globalTagsString;
            } else {
                setStatus('globalTagsStatus', 'Error: Failed to save to Supabase.', true);
            }
        }
        
        function renderGlobalTags() {
            const inputEl = document.getElementById('defaultTagsInput');
            if (inputEl) {
                inputEl.value = globalTagsString;
            }
        }

        // NEW: Load existing extra tags when event name input changes
        function loadEventExtraTags() {
            const eventName = document.getElementById('inputEventName').value.trim();
            const extraTagsInput = document.getElementById('extraHashtagsInput');
            
            if (eventExtraTags[eventName]) {
                extraTagsInput.value = eventExtraTags[eventName];
                extraTagsInput.placeholder = `Suggested tags for this event type: ${eventExtraTags[eventName]}`;
            } else {
                extraTagsInput.value = '';
                extraTagsInput.placeholder = "Suggested tags for this event type will appear here.";
            }
        }

        // --- DATA MANAGEMENT: SCHEDULER & HISTORY ---
        
        // Helper function to manage the delayed saving
        const saveScheduleWithDelay = () => {
            if (saveScheduleTimeout) {
                clearTimeout(saveScheduleTimeout);
            }
            saveScheduleTimeout = setTimeout(async () => {
                await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule);
                // Clear the timeout reference after saving
                saveScheduleTimeout = null;
            }, 3500); // 3.5 second delay
        };


        function initializeSortable() {
            const dateGroups = document.querySelectorAll('.event-group');
            
            dateGroups.forEach(group => {
                const list = group.querySelector('.scheduled-list');
                
                if (Sortable.get(list)) {
                    Sortable.get(list).destroy();
                }
                if (!list) return;

                new Sortable(list, {
                    animation: 150,
                    ghostClass: 'sortable-drag',
                    // Dragging is now local to the date group
                    onEnd: async function (evt) {
                        const dateKey = group.dataset.date;
                        
                        // Filter and sort the current events for this day to match the DOM order
                        const originalSchedule = eventSchedule.filter(e => e.date === dateKey).sort((a, b) => a.order - b.order);
                        
                        if (evt.oldIndex === evt.newIndex) return;

                        const movedItem = originalSchedule[evt.oldIndex];
                        originalSchedule.splice(evt.oldIndex, 1);
                        originalSchedule.splice(evt.newIndex, 0, movedItem);

                        // Update the 'order' property for all items in the group
                        const updatedSchedule = eventSchedule.map(e => {
                            if (e.date === dateKey) {
                                // Find the new order index from the manipulated array
                                const newOrder = originalSchedule.findIndex(item => item.eventName === e.eventName && item.date === e.date);
                                // Only update if the item was found
                                if (newOrder !== -1) {
                                    e.order = newOrder;
                                }
                            }
                            return e;
                        });
                        
                        // Update the global list and save
                        eventSchedule.splice(0, eventSchedule.length, ...updatedSchedule.sort((a, b) => new Date(a.date) - new Date(b.date) || a.order - b.order));
                        
                        await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule); // Save instantly for drag/drop
                    },
                });
            });
        }
        
        function renderScheduleList() {
            const containerEl = document.getElementById('scheduledEventsContainer'); 
            const historyListEl = document.getElementById('historyEventsList');
            const messageEl = document.getElementById('emptyScheduleMessage');
            const today = getTodayIsoString();
            const yesterday = getYesterdayIsoString();
            
            if (!containerEl || !historyListEl || !messageEl) return;
            
            containerEl.innerHTML = '';
            historyListEl.innerHTML = '';
            
            const allEventsWithDay = calculateSequentialDays(eventSchedule);

            const upcomingEvents = [];
            const pastEvents = [];

            allEventsWithDay.forEach(event => {
                // Initialize status fields if missing (for legacy data)
                if (event.postStatus === undefined) event.postStatus = 'pending';
                if (event.storyStatus === undefined) event.storyStatus = 'pending';
                if (event.order === undefined) event.order = eventSchedule.filter(e => e.date === event.date).length;

                // RULE 1: Auto-move to history if the event date is strictly in the past (yesterday or earlier)
                if (event.date <= yesterday) {
                    pastEvents.push(event);
                } 
                // RULE 2: Manual move to history if post/story are both done (regardless of date, in case of early completion)
                else if (event.postStatus === 'done' && event.storyStatus === 'done') {
                    pastEvents.push(event);
                }
                // OTHERWISE: Keep in the upcoming schedule list
                else { 
                    upcomingEvents.push(event);
                }
            });

            // Sort upcoming events: date primary, custom order secondary
            upcomingEvents.sort((a, b) => new Date(a.date) - new Date(b.date) || a.order - b.order);

            // --- Render Schedule Tab (Grouped by Date for reordering) ---
            
            const groupedByDate = upcomingEvents.reduce((acc, event) => {
                const dateKey = event.date;
                if (!acc[dateKey]) acc[dateKey] = [];
                acc[dateKey].push(event);
                return acc;
            }, {});

            if (upcomingEvents.length === 0) {
                messageEl.classList.remove('hidden');
            } else {
                messageEl.classList.add('hidden');
            }

            for (const dateKey in groupedByDate) {
                const group = groupedByDate[dateKey];
                
                const groupDiv = document.createElement('div');
                groupDiv.className = 'event-group';
                groupDiv.dataset.date = dateKey;
                groupDiv.innerHTML = `
                    <h3 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2 flex justify-between items-center">
                        <div>ðŸ—“ Day ${group[0].dayNumber} - ${group[0].inputDateFriendly}</div>
                        <div class="text-sm font-normal text-gray-500 flex space-x-2">
                             <span>(Drag to reorder)</span>
                             <button onclick="copyDayEventNames('${dateKey}')" class="text-xs px-2 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 transition">Copy Day Event List</button>
                        </div>
                    </h3>
                    <div class="scheduled-list space-y-4">
                    </div>
                `;
                const listEl = groupDiv.querySelector('.scheduled-list');
                
                group.forEach((event) => {
                    const postTextId = `schedule-post-text-${event.date}-${event.eventName}`;
                    const tagsOnlyId = `schedule-tags-only-${event.date}-${event.eventName}`;
                    const dayPrefix = `ðŸŒ•Full Moon Week - Day ${event.dayNumber}ðŸŒ•\n`;
                    const finalPostText = dayPrefix + event.postText; 
                    
                    const postDone = event.postStatus === 'done';
                    const storyDone = event.storyStatus === 'done';

                    const div = document.createElement('div');
                    // ADDED CLASS: scheduled-event-card for styling hook
                    div.className = 'scheduled-event-card p-4 border border-gray-200 rounded-lg bg-white shadow-sm space-y-3 cursor-grab';
                    div.onclick = () => loadEventForEdit(event); 
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-start flex-wrap">
                            <div class="flex-grow min-w-0 pr-4 flex flex-col sm:flex-row sm:items-center sm:space-x-4">
                                <h3 class="font-bold text-primary inline">${event.eventName} <span class="text-gray-500 font-medium ml-2 text-sm">| Order: ${event.order}</span></h3>
                                <p class="text-gray-700 inline-block mt-1 sm:mt-0 flex-wrap flex">
                                    ðŸ“ Location: ${event.location}
                                </p>
                            </div>
                            
                            <div class="flex space-x-1 flex-shrink-0 mt-2 sm:mt-0 items-center">
                                <!-- Status Toggles -->
                                <button 
                                    onclick="event.stopPropagation(); togglePostStatus('${event.date}', '${event.eventName}')" 
                                    class="px-2 py-1 rounded-full transition ${postDone ? 'bg-secondary text-white' : 'bg-gray-200 text-gray-600 hover:bg-secondary hover:text-white'}"
                                >
                                    ${postDone ? 'âœ… Post Done' : 'Post'}
                                </button>
                                <button 
                                    onclick="event.stopPropagation(); toggleStoryStatus('${event.date}', '${event.eventName}')" 
                                    class="px-2 py-1 rounded-full transition ${storyDone ? 'bg-secondary text-white' : 'bg-gray-200 text-gray-600 hover:bg-secondary hover:text-white'}"
                                >
                                    ${storyDone ? 'âœ… Story Done' : 'Story'}
                                </button>
                                
                                <button onclick="event.stopPropagation(); saveEventAsTemplate(event)" class="px-2 py-1 bg-gray-500 text-white rounded-full hover:bg-gray-600 transition">Template</button>
                                <button onclick="event.stopPropagation(); copyToClipboard(document.getElementById('${postTextId}').value)" class="px-2 py-1 bg-primary text-white rounded-full hover:bg-indigo-600 transition">Copy Post</button>
                                <button onclick="event.stopPropagation(); copyToClipboard(document.getElementById('${tagsOnlyId}').value)" class="px-2 py-1 bg-secondary text-white rounded-full hover:bg-emerald-600 transition">Copy Tags</button>
                                <button onclick="event.stopPropagation(); handleDeleteScheduledEvent('${event.date}', '${event.eventName}')" class="text-red-500 hover:text-red-700 p-1 transition" title="Delete Event">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-4 gap-2">
                            <div class="col-span-3">
                                <label class="block font-medium text-gray-700">Post/Reel Text:</label>
                                <textarea 
                                    id="${postTextId}" 
                                    onblur="updateScheduledEventText('${event.date}', '${event.eventName}', this.value, 'postText')" 
                                    class="w-full border rounded-lg bg-white focus:ring-primary focus:border-primary" rows="5"
                                >${finalPostText}</textarea>
                            </div>
                            <div class="col-span-1">
                                <label class="block font-medium text-gray-700">Story Tags:</label>
                                <textarea 
                                    id="${tagsOnlyId}" 
                                    onblur="updateScheduledEventText('${event.date}', '${event.eventName}', this.value, 'tagsOnly')" 
                                    class="w-full border rounded-lg bg-white focus:ring-primary focus:border-primary" rows="5"
                                >${event.tagsOnly}</textarea>
                            </div>
                        </div>
                    `;
                    listEl.appendChild(div);
                });
                
                containerEl.appendChild(groupDiv);
            }
            
            // --- Render History Tab ---
            renderHistoryList(pastEvents);
        }

        async function togglePostStatus(date, eventName) {
            const globalIndex = eventSchedule.findIndex(e => e.date === date && e.eventName === eventName);
            if (globalIndex === -1) return;
            
            const currentStatus = eventSchedule[globalIndex].postStatus;
            eventSchedule[globalIndex].postStatus = currentStatus === 'done' ? 'pending' : 'done';
            
            saveScheduleWithDelay();
            debouncedRenderScheduleList(); // Immediate local render for visual feedback
        }

        async function toggleStoryStatus(date, eventName) {
            const globalIndex = eventSchedule.findIndex(e => e.date === date && e.eventName === eventName);
            if (globalIndex === -1) return;
            
            const currentStatus = eventSchedule[globalIndex].storyStatus;
            eventSchedule[globalIndex].storyStatus = currentStatus === 'done' ? 'pending' : 'done';
            
            saveScheduleWithDelay();
            debouncedRenderScheduleList(); // Immediate local render for visual feedback
        }

        function copyDayEventNames(dateKey) {
            const eventsForDay = eventSchedule
                .filter(e => e.date === dateKey)
                .sort((a, b) => a.order - b.order)
                .map(e => e.eventName);
            
            const listToCopy = eventsForDay.join('\n');
            copyToClipboard(listToCopy);

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = `Copied ${eventsForDay.length} event names for ${formatDateFriendly(dateKey)}.`;
            statusMessage.className = 'mt-4 sm:mt-0 text-sm text-primary font-bold w-full text-center sm:text-left';
        }

        
        // NEW: Updated signature to use unique identifiers instead of index
        async function updateScheduledEventText(date, eventName, value, field) {
            
            const globalIndex = eventSchedule.findIndex(e => e.date === date && e.eventName === eventName);

            if (globalIndex === -1) {
                console.error("Critical: Could not find event in global list to update.");
                return;
            }

            if (field === 'postText') {
                const dayPrefixRegex = /ðŸŒ•Full Moon Week - Day \d+ðŸŒ•\n?/;
                const strippedValue = value.replace(dayPrefixRegex, '').trim();
                eventSchedule[globalIndex].postText = strippedValue;
            } else {
                eventSchedule[globalIndex][field] = value;
            }
            
            await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule); // Save instantly for text edits
        }

        // NEW: Updated signature to use unique identifiers instead of index
        async function handleDeleteScheduledEvent(date, eventName) {
            const eventToDelete = eventSchedule.find(e => e.date === date && e.eventName === eventName);
            if (!eventToDelete) return;
            
            const confirmed = await openModal(`Delete scheduled event: "${eventToDelete.eventName}"?`);

            if (confirmed) {
                const globalIndex = eventSchedule.findIndex(e => e.date === date && e.eventName === eventName);
                if (globalIndex > -1) {
                    eventSchedule.splice(globalIndex, 1); 
                    await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule);
                }
            }
        }
        
        function renderHistoryList(pastEvents = []) {
            const listEl = document.getElementById('historyEventsList');
            const messageEl = document.getElementById('emptyHistoryMessage');

            if (!listEl || !messageEl) return;
            
            listEl.innerHTML = '';

            if (pastEvents.length === 0) {
                messageEl.classList.remove('hidden');
                return;
            }
            messageEl.classList.add('hidden');

            // History is always sorted by newest first
            pastEvents.sort((a, b) => new Date(b.date) - new Date(a.date));

            const groupedHistory = pastEvents.reduce((acc, event) => {
                const date = new Date(event.date + 'T00:00:00');
                const groupKey = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
                if (!acc[groupKey]) {
                    acc[groupKey] = [];
                }
                acc[groupKey].push(event);
                return acc;
            }, {});
            
            let isFirstGroup = true;

            for (const groupKey in groupedHistory) {
                const group = groupedHistory[groupKey];
                const groupId = `history-group-${groupKey.replace(/\s/g, '-')}`;
                const isExpanded = isFirstGroup;
                isFirstGroup = false;

                const button = document.createElement('button');
                button.className = 'collapsible-btn mt-6';
                button.setAttribute('data-state', isExpanded ? 'expanded' : 'collapsed');
                button.setAttribute('onclick', `toggleCollapsible('${groupId}', this)`);
                button.innerHTML = `${groupKey} (${group.length} events) <svg class="w-4 h-4 transform transition-transform ${isExpanded ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>`;
                listEl.appendChild(button);

                const groupContent = document.createElement('div');
                groupContent.id = groupId;
                groupContent.className = isExpanded ? 'space-y-3 p-2' : 'hidden space-y-3 p-2';
                
                group.forEach((event, index) => {
                    const uniqueId = `history-detail-${event.date}-${index}`; 
                    const dayPrefix = `ðŸŒ•Day ${event.dayNumber}ðŸŒ•`;

                    const div = document.createElement('div');
                    div.className = 'p-3 border border-gray-200 rounded-lg bg-white shadow-sm text-sm';
                    div.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div class="flex-grow min-w-0 pr-4">
                                <h3 class="font-bold text-gray-800">${event.eventName} <span class="text-gray-500 font-medium ml-2 text-sm">${dayPrefix}</span></h3>
                                <p class="text-xs text-gray-600">ðŸ—“ ${event.inputDateFriendly} | ðŸ“ ${event.location}</p>
                            </div>
                            
                            <div class="flex space-x-2 flex-shrink-0">
                                <button onclick="toggleCollapsible('${uniqueId}', this)" class="text-xs px-2 py-1 bg-gray-400 text-white rounded hover:bg-gray-500 transition" data-state="collapsed">View Details</button>
                                <button onclick="duplicateToEditor(${JSON.stringify(event).replace(/"/g, '&quot;')})" class="text-xs px-2 py-1 bg-primary text-white rounded hover:bg-indigo-600 transition">Duplicate</button>
                                <button onclick="event.stopPropagation(); saveEventAsTemplate(event)" class="text-xs px-2 py-1 bg-gray-500 text-white rounded-full hover:bg-gray-600 transition">Save as Template</button>
                                <button onclick="handleDeleteHistoryEvent('${event.date}', '${event.eventName}')" class="text-red-500 hover:text-red-700 p-1 transition" title="Delete History Event">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        </div>
                        <div id="${uniqueId}" class="mt-3 p-3 bg-gray-100 rounded-lg hidden w-full">
                            <p class="text-xs font-medium text-gray-700 mb-1">Post Text:</p>
                            <pre class="whitespace-pre-wrap text-xs bg-white p-2 rounded">${event.postText}</pre>
                            <p class="text-xs font-medium text-gray-700 mt-2 mb-1">Story Tags:</p>
                            <pre class="whitespace-pre-wrap text-xs bg-white p-2 rounded">${event.tagsOnly}</pre>
                        </div>
                    `;
                    groupContent.appendChild(div);
                });

                listEl.appendChild(groupContent);
            }
            listEl.dataset.pastEvents = JSON.stringify(pastEvents);
        }
        
        // NEW: Updated signature to use unique identifiers instead of index
        async function handleDeleteHistoryEvent(date, eventName) {
            const eventToRemove = eventSchedule.find(e => e.date === date && e.eventName === eventName);

            if (!eventToRemove) return;
            const confirmed = await openModal(`Delete historical event: "${eventToRemove.eventName}"?`);

            if (confirmed) {
                const globalIndex = eventSchedule.findIndex(e => e.date === eventToRemove.date && e.eventName === eventToRemove.eventName);
                if (globalIndex > -1) {
                    eventSchedule.splice(globalIndex, 1);
                    await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule);
                }
            }
        }
        
        function loadEventForEdit(event) {
             // Load content into the editor tab fields
            document.getElementById('inputEventName').value = event.eventName;
            document.getElementById('inputLocation').value = event.location;
            document.getElementById('inputIsoDate').value = event.date;
            
            const rawDescription = event.postText
                .replace(/^ðŸ—“ DATE:.*\n/, '')
                .replace(/^ðŸŽ‰ EVENT:.*\n/, '')
                .replace(/^ðŸ“ LOCATION:.*\n/, '')
                .replace(/#\w+/g, '') 
                .trim();

            document.getElementById('rawDescription').value = rawDescription;
            
            // Trigger extra tags load for this event
            const extraTagsInput = document.getElementById('extraHashtagsInput');
            extraTagsInput.value = eventExtraTags[event.eventName] || '';

            showTab('editor');
        }

        async function saveEventAsTemplate(event) {
            const templateName = await openPromptModal("Enter a name for this template:");
            
            if (!templateName || templateName.trim() === "") return;

            const eventName = event.eventName;
            const location = event.location;
            
            const description = event.postText
                .replace(/^ðŸ—“ DATE:.*\n/, '')
                .replace(/^ðŸŽ‰ EVENT:.*\n/, '')
                .replace(/^ðŸ“ LOCATION:.*\n/, '')
                .replace(/#\w+/g, '') 
                .trim();

            eventDatabase[templateName] = {
                location: location,
                eventName: eventName,
                description: description
            };

            const saveSuccess = await saveDataToSupabase(DB_CONFIG.EVENT_DB_KEY, eventDatabase);
            
            if (saveSuccess) {
                 console.log(`Template "${templateName}" saved!`);
                 document.getElementById('statusMessage').textContent = `Template "${templateName}" saved successfully.`;
                 document.getElementById('statusMessage').className = 'mt-4 sm:mt-0 text-sm text-primary font-bold w-full text-center sm:text-left';
            } else {
                 document.getElementById('statusMessage').textContent = `Error saving template: failed to connect to Supabase.`;
                 document.getElementById('statusMessage').className = 'mt-4 sm:mt-0 text-sm text-red-600 font-bold w-full text-center sm:text-left';
            }
        }

        function duplicateToEditor(event) {
            document.getElementById('inputEventName').value = event.eventName;
            document.getElementById('inputLocation').value = event.location;
            
            const rawDescription = event.postText
                .replace(/^ðŸ—“ DATE:.*\n/, '')
                .replace(/^ðŸŽ‰ EVENT:.*\n/, '')
                .replace(/^ðŸ“ LOCATION:.*\n/, '')
                .replace(/#\w+/g, '') 
                .trim();

            document.getElementById('rawDescription').value = rawDescription;
            document.getElementById('inputIsoDate').value = ""; 
            document.getElementById('extraHashtagsInput').value = eventExtraTags[event.eventName] || ""; 

            showTab('editor');
        }

        // --- DATA MANAGEMENT: SNIPPETS & TEMPLATES ---
        
        function renderEditorSnippetSelect() {
            const selectEl = document.getElementById('editorSnippetSelect');
            if (!selectEl) return;
            
            selectEl.innerHTML = '<option value="">--- Select Snippet ---</option>';
            const names = Object.keys(textSnippets).sort();
            names.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectEl.appendChild(option);
            });
        }
        
        function insertSnippet() {
            const selectEl = document.getElementById('editorSnippetSelect');
            const name = selectEl.value;
            const descriptionEl = document.getElementById('rawDescription');

            if (name && textSnippets[name]) {
                const start = descriptionEl.selectionStart;
                const end = descriptionEl.selectionEnd;
                const value = descriptionEl.value;
                
                descriptionEl.value = value.substring(0, start) + textSnippets[name] + value.substring(end);
                
                descriptionEl.selectionStart = descriptionEl.selectionEnd = start + textSnippets[name].length;

                document.getElementById('snippetMenu').classList.add('hidden');
            }
            selectEl.value = ''; 
        }
        
        function renderSnippetSelect() {
            const selectEl = document.getElementById('snippetSelect');
            if (!selectEl) return;
            
            selectEl.innerHTML = '<option value="">--- Load Snippet ---</option>';
            const names = Object.keys(textSnippets).sort();
            names.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectEl.appendChild(option);
            });
        }

        function loadSnippet() {
            const name = document.getElementById('snippetSelect').value;
            const contentEl = document.getElementById('snippetContent');
            const nameInputEl = document.getElementById('snippetName');
            
            if (name && textSnippets[name]) {
                contentEl.value = textSnippets[name];
                nameInputEl.value = name;
            } else {
                contentEl.value = '';
                nameInputEl.value = '';
            }
        }

        async function saveSnippet() {
            const name = document.getElementById('snippetName').value.trim();
            const content = document.getElementById('snippetContent').value.trim();
            const statusEl = document.getElementById('snippetStatus');

            if (!name || !content) {
                setStatus('snippetStatus', 'Name and content are required.', true);
                return;
            }

            textSnippets[name] = content;
            const saveSuccess = await saveDataToSupabase(DB_CONFIG.SNIPPETS_KEY, textSnippets);
            
            if (saveSuccess) {
                 setStatus('snippetStatus', `Snippet "${name}" saved!`);
            } else {
                 setStatus('snippetStatus', 'Error: Failed to save to Supabase.', true);
            }
        }

        async function removeSnippet(button) {
            const nameToRemove = button.getAttribute('data-name');
            const confirmed = await openModal(`Are you sure you want to remove snippet "${nameToRemove}"?`);

            if(confirmed) {
                delete textSnippets[nameToRemove];
                await saveDataToSupabase(DB_CONFIG.SNIPPETS_KEY, textSnippets);
            }
        }
        
        function renderEventTemplateSelect() {
            const selectEl = document.getElementById('eventTemplateSelect');
            if (!selectEl) return; 
            
            selectEl.innerHTML = '<option value="">--- Select Event Template ---</option>';

            const names = Object.keys(eventDatabase).sort();
            
            names.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectEl.appendChild(option);
            });
        }

        function loadEventTemplate() {
            const name = document.getElementById('eventTemplateSelect').value;
            const statusMessage = document.getElementById('statusMessage');

            if (name && eventDatabase[name]) {
                const template = eventDatabase[name];
                
                document.getElementById('inputIsoDate').value = ""; 
                document.getElementById('inputEventName').value = template.eventName || name;
                document.getElementById('inputLocation').value = template.location;
                document.getElementById('rawDescription').value = template.description;
                
                // Load recurring extra tags if they exist for this event name
                const eventName = template.eventName || name;
                document.getElementById('extraHashtagsInput').value = eventExtraTags[eventName] || '';

                statusMessage.textContent = `Template "${name}" loaded.`;
                statusMessage.className = 'mt-4 sm:mt-0 text-sm text-primary font-bold w-full text-center sm:text-left';
            }
        }
        
        // --- CORE PARSING LOGIC (FINALIZED) ---

        function processStructuredEvent(structuredData, description, extraHashtags, instaMap, defaultHashtags) {
            
            let allTagsWithOrder = []; 
            const existingTags = new Set(); 
            const block = description; 
            
            const tagMatches = Array.from(block.matchAll(/@(\w+\.?\w+)/g));
            
            tagMatches.forEach(match => {
                const tag = match[0].toLowerCase();
                if (!existingTags.has(tag)) {
                    allTagsWithOrder.push({ tag: tag, index: match.index });
                    existingTags.add(tag);
                }
            });

            let postDescription = description;
            const sortedNames = Object.keys(instaMap).sort((a, b) => b.length - a.length); 

            sortedNames.forEach(name => {
                const tagToInject = instaMap[name].tag;
                const tagToInjectLower = tagToInject.toLowerCase();

                if (existingTags.has(tagToInjectLower)) {
                    return; 
                }

                const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const injectionRegex = new RegExp(`(\\b${escapedName}\\b)(?!\\s*@\\w+)`, 'gi'); 
                
                let foundMatchInCurrentIteration = false;

                postDescription = postDescription.replace(injectionRegex, (match, p1) => {
                    if (!foundMatchInCurrentIteration) {
                        existingTags.add(tagToInjectLower); 
                        foundMatchInCurrentIteration = true; 
                        
                        const firstMatchIndex = postDescription.toLowerCase().indexOf(p1.toLowerCase()); 
                        if (firstMatchIndex > -1) {
                           allTagsWithOrder.push({ tag: tagToInjectLower, index: firstMatchIndex });
                        }

                        return `${p1} ${tagToInject}`; 
                    }
                    
                    return p1; 
                });
            });

            
            const extraTagsArray = extraHashtags.split(',').map(t => `#${t.trim().replace(/^#/, '').toLowerCase()}`).filter(t => t.length > 0);
            
            const defaultHashtagsSet = new Set(defaultHashtags.map(t => `#${t.toLowerCase()}`));
            const finalHashtags = [...defaultHashtagsSet.values(), ...extraTagsArray].filter((tag, index, self) => self.indexOf(tag) === index);
            
            allTagsWithOrder.sort((a, b) => a.index - b.index);
            
            const orderedInstaTags = [];
            const seenAtTags = new Set(); 
            allTagsWithOrder.forEach(item => {
                if (item.tag.startsWith('@') && !seenAtTags.has(item.tag)) {
                    orderedInstaTags.push(item.tag);
                    seenAtTags.add(item.tag);
                }
            });
            
            const hashtagsOutput = finalHashtags.filter(tag => tag.startsWith('#')).join(' ');

            const dateFriendly = formatDateFriendly(structuredData.isoDate);

            const basePostText = 
                `ðŸ—“ DATE: ${dateFriendly}\n` + 
                `ðŸŽ‰ EVENT: ${structuredData.eventName}\n` + 
                `ðŸ“ LOCATION: ${structuredData.location}\n` + 
                `\n` +
                postDescription.trim() + 
                `\n\n` +
                `${hashtagsOutput}`;

            return {
                postText: basePostText,
                tagsOnly: orderedInstaTags.join('\n'), 
            };
        }

        // --- MAIN HANDLER ---

        async function handleClick(saveToSchedule) {
            const structuredData = {
                isoDate: document.getElementById('inputIsoDate').value.trim(),
                eventName: document.getElementById('inputEventName').value.trim(),
                location: document.getElementById('inputLocation').value.trim(),
            };
            
            const dateFriendly = formatDateFriendly(structuredData.isoDate);
            const mediaFileName = generateFileName(); 
            const rawDescriptionInput = document.getElementById('rawDescription');
            const description = rawDescriptionInput.value;
            
            const extraHashtagsInput = document.getElementById('extraHashtagsInput');
            const extraHashtags = extraHashtagsInput.value;
            
            const defaultTagsStr = globalTagsString; 
            const statusMessage = document.getElementById('statusMessage');

            statusMessage.textContent = 'Processing...';

            const defaultHashtags = defaultTagsStr
                .split(',')
                .map(tag => tag.trim().replace(/^#/, ''))
                .filter(tag => tag.length > 0);

            if (!structuredData.isoDate || !structuredData.eventName || !description.trim()) {
                 statusMessage.className = 'mt-4 sm:mt-0 text-sm text-red-600 font-bold w-full text-center sm:text-left';
                 statusMessage.textContent = 'Error: Date, Event Name, and Description are required fields.';
                 return;
            }

            try {
                const result = processStructuredEvent(structuredData, description, extraHashtags, nameTagDatabase, defaultHashtags);
                
                const finalPostTextForDisplay = `ðŸŒ•Full Moon Week - Day XðŸŒ•\n${result.postText}`;

                document.getElementById('calendarOutput').value = finalPostTextForDisplay;
                document.getElementById('tagsOnlyOutput').value = result.tagsOnly;

                if (saveToSchedule) {
                    // 1. Save recurring extra hashtags keyed by eventName
                    const currentExtraTags = extraHashtags.trim();
                    if (currentExtraTags.length > 0) {
                        eventExtraTags[structuredData.eventName] = currentExtraTags;
                        await saveDataToSupabase(DB_CONFIG.EXTRA_TAGS_KEY, eventExtraTags);
                    } else if (eventExtraTags[structuredData.eventName]) {
                        delete eventExtraTags[structuredData.eventName];
                        await saveDataToSupabase(DB_CONFIG.EXTRA_TAGS_KEY, eventExtraTags);
                    }
                    
                    // 2. Save event data
                    const savedPostText = document.getElementById('calendarOutput').value.replace(/ðŸŒ•Full Moon Week - Day XðŸŒ•\n?/, '').replace(/ðŸŒ•Full Moon Week - Day \d+ðŸŒ•\n?/, ''); 
                    const savedTagsOnly = document.getElementById('tagsOnlyOutput').value;

                    const existingEvent = eventSchedule.find(e => e.date === structuredData.isoDate && e.eventName === structuredData.eventName);

                    const newEventData = {
                        eventName: structuredData.eventName,
                        date: structuredData.isoDate,
                        location: structuredData.location, 
                        inputDateFriendly: dateFriendly,
                        postText: savedPostText,  
                        tagsOnly: savedTagsOnly,
                        mediaFileName: mediaFileName,
                        order: existingEvent ? existingEvent.order : (eventSchedule.filter(e => e.date === structuredData.isoDate).length), 
                        extraTags: currentExtraTags,
                        postStatus: existingEvent ? existingEvent.postStatus : 'pending', // Retain or set default
                        storyStatus: existingEvent ? existingEvent.storyStatus : 'pending' // Retain or set default
                    };

                    if (existingEvent) {
                        const globalIndex = eventSchedule.findIndex(e => e.date === existingEvent.date && e.eventName === existingEvent.eventName);
                        eventSchedule[globalIndex] = newEventData;
                        statusMessage.textContent = `Event "${structuredData.eventName}" updated in Scheduler!`;
                    } else {
                        eventSchedule.push(newEventData);
                        statusMessage.textContent = `Event "${structuredData.eventName}" saved to Scheduler!`;
                    }
                    
                    const saveSuccess = await saveDataToSupabase(DB_CONFIG.SCHEDULE_DB_KEY, eventSchedule);

                    if (saveSuccess) {
                        statusMessage.className = 'mt-4 sm:mt-0 text-sm text-accent font-bold w-full text-center sm:text-left';
                        showTab('scheduler');
                    } else {
                         statusMessage.className = 'mt-4 sm:mt-0 text-sm text-red-600 font-bold w-full text-center sm:text-left';
                         statusMessage.textContent = 'Error saving event: failed to connect to Supabase.';
                    }

                } else {
                    statusMessage.className = 'mt-4 sm:mt-0 text-sm text-secondary font-bold w-full text-center sm:text-left';
                    statusMessage.textContent = 'Parsing Complete! Click to Save';
                }

            } catch (e) {
                console.error(e);
                statusMessage.className = 'mt-4 sm:mt-0 text-sm text-red-600 font-bold w-full text-center sm:text-left';
                statusMessage.textContent = `Critical Error: ${e.message}. Check console.`;
            }
        }

        // --- INITIALIZATION ---
        
        function render() {
             debouncedRenderNameMap();
             debouncedRenderEventTemplateSelect();
             debouncedRenderSnippetSelect();
             debouncedRenderGlobalTags();
             // debouncedRenderMediaLink(); // REMOVED
             debouncedRenderScheduleList();
             debouncedRenderCalendarSummary();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeSupabase();
            document.getElementById('inputIsoDate').value = getTodayIsoString();

            document.getElementById('inputEventName').value = "";
            document.getElementById('inputLocation').value = "";
            document.getElementById('rawDescription').value = "";
            document.getElementById('extraHashtagsInput').value = "";
            document.getElementById('calendarOutput').value = "";
            document.getElementById('tagsOnlyOutput').value = "";
        });
        
    </script>
</body>
</html>
